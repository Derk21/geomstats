import inspect
import types

import pytest

import geomstats.backend as gs


def _copy_func(f, name=None):
    """Return a function with same code, globals, defaults, closure, and
    name (or provide a new name).

    Additionally, keyword arguments are transformed into positional arguments for
    compatibility with pytest.
    """
    fn = types.FunctionType(
        f.__code__, f.__globals__, name or f.__name__, f.__defaults__, f.__closure__
    )
    fn.__dict__.update(f.__dict__)

    sign = inspect.signature(fn)
    defaults, new_params = {}, []
    for param in sign.parameters.values():
        if param.default is inspect._empty:
            new_params.append(param)
        else:
            new_params.append(inspect.Parameter(param.name, kind=1))
            defaults[param.name] = param.default
    new_sign = sign.replace(parameters=new_params)
    fn.__signature__ = new_sign

    return fn, defaults


def _get_tolerances(testing_data):
    return testing_data.tolerances if hasattr(testing_data, "tolerances") else {}


def _check_test_data_pairing(test_attrs, data_names_ls):
    not_paired = []
    for test_name in test_attrs:
        data_name = _test_name_to_test_data_name(test_name)
        if data_name not in data_names_ls:
            not_paired.append(test_name)

    if not_paired:
        msg = "Need to define data for:"
        for test_name in not_paired:
            msg += f"\n\t-{test_name}"

        raise Exception(msg)


def _parametrize_test_func(test_func, attr_name, testing_data, default_values):
    arg_names = inspect.getfullargspec(test_func)[0]
    args_str = ", ".join(arg_names[1:])

    # TODO: allow marks from data in this case?
    # no args case (note selection was done above)
    if len(arg_names) == 1:
        return test_func

    test_data = _get_test_data(
        attr_name,
        testing_data,
        arg_names,
        default_values,
    )

    return pytest.mark.parametrize(args_str, test_data)(test_func)


class TestBasedParametrizer(type):
    """Metaclass for test classes.

    Note: A test class is a class that inherits from TestCase.
    For example, `class TestEuclidean(TestCase)` defines
    a test class.

    The Parametrizer helps its test class by pairing:
    - the different test functions of the test class:
      - e.g. the test function `test_belongs`,
    - with different test data, generated by auxiliary test data functions
      - e.g. the test data function `belongs_data` that generates data
      to test the function `belongs`.

    As such, Parametrizer acts as a "metaclass" of its test class:
    `class TestEuclidean(TestCase, metaclass=Parametrizer)`.

    Specifically, Parametrizer decorates every test function inside
    its test class with pytest.mark.parametrizer, with the exception
    of the test class' class methods and static methods.

    Two conventions need to be respected:
    1. The test class should contain an attribute named 'testing_data'.
      - `testing_data` is an object inheriting from `TestData`.
    2. Every test function should have its corresponding test data function created
    inside the TestData object called `testing_data`.

    A sample test class looks like this:

    ```
    class TestEuclidean(TestCase, metaclass=Parametrizer):
        class TestDataEuclidean(TestData):
            def belongs_data():
                ...
                return self.generate_tests(...)
        testing_data = TestDataEuclidean()
        def test_belongs():
            ...
    ```
    Parameters
    ----------
    cls : child class of TestCase
        Test class, i.e. a class inheriting from TestCase
    name : str
        Name of the test class
    bases : TestCase
        Parent class of the test class: TestCase.
    attrs : dict
        Attributes of the test class, for example its methods,
        stored in a dictionnary as (key, value) when key gives the
        name of the attribute (for example the name of the method),
        and value gives the actual attribute (for example the method
        itself.)

    References
    ----------
    More on pytest's parametrizers can be found here:
    https://docs.pytest.org/en/6.2.x/parametrize.html
    """

    def __new__(cls, name, bases, attrs):
        # TODO: use skipif instead? check if collection if performed
        # skip_all = attrs.get("skip_all", False)

        all_test_attrs = _collect_all_tests(attrs, bases)

        testing_data = locals()["attrs"].get("testing_data")
        if testing_data is None:
            raise Exception(
                "Testing class doesn't have class object" " named 'testing_data'"
            )

        data_names_ls = _collect_testing_data_tests(testing_data)
        _check_test_data_pairing(all_test_attrs, data_names_ls)

        # TODO: warn about unused data?

        for attr_name, attr_value in all_test_attrs.copy().items():
            test_func, default_values = _copy_func(attr_value)

            # TODO: move skips to data?
            if (f"skip_{attr_name}", True) in locals()["attrs"].items():
                attrs[attr_name] = pytest.mark.skip("skipped")(test_func)
            else:

                attrs[attr_name] = _parametrize_test_func(
                    test_func, attr_name, testing_data, default_values
                )

        return super().__new__(cls, name, bases, attrs)


def _get_test_data(test_name, testing_data, test_arg_names, default_values):
    # assumes pairing test-data exists

    data_name = _test_name_to_test_data_name(test_name)
    test_data = getattr(testing_data, data_name)()

    if test_data is None:
        raise Exception(f"'{data_name}' returned None. should be list")

    test_data = _dictify_test_data(test_data, test_arg_names[1:])

    cls_tols = _get_tolerances(testing_data)
    test_data = _handle_tolerances(
        test_name[5:],
        test_arg_names[1:],
        test_data,
        cls_tols,
    )
    test_data = _pytestify_test_data(
        test_name, test_data, test_arg_names[1:], default_values
    )

    return test_data


def _dictify_test_data(test_data, arg_names):
    tests = []
    for test_datum in test_data:
        if not isinstance(test_datum, dict):
            test_datum = dict(zip(arg_names, test_datum[:-1]))
            test_datum["marks"] = test_datum[-1]

        tests.append(test_datum)

    return tests


def _handle_tolerances(func_name, arg_names, test_data, cls_tols):
    has_tol = False
    for arg_name in arg_names:
        if arg_name.endswith("tol"):
            has_tol = True
            break

    if not has_tol:
        return test_data

    func_tols = cls_tols.get(func_name, {})

    tols = {}
    for arg_name in arg_names:
        if arg_name.endswith("rtol"):
            tols[arg_name] = func_tols.get(arg_name, gs.rtol)
        elif arg_name.endswith("tol"):
            tols[arg_name] = func_tols.get(arg_name, gs.atol)

    for test_datum in test_data:
        for tol_arg_name, tol in tols.items():
            test_datum.setdefault(tol_arg_name, tol)

    return test_data


def _pytestify_test_data(func_name, test_data, arg_names, default_values):
    tests = []
    for test_datum in test_data:
        try:
            values = [
                test_datum.get(key) if key in test_datum else default_values[key]
                for key in arg_names
            ]

        except KeyError:
            raise Exception(
                f"{func_name} requires the following arguments: "
                f"{', '.join(arg_names)}"
            )
        tests.append(pytest.param(*values, marks=test_datum.get("marks")))

    return tests


def _is_test(attr_name):
    return attr_name.startswith("test_")


def _is_test_data(attr_name):
    return attr_name.endswith("_test_data")


def _test_name_to_test_data_name(test_name):
    return test_name[5:] + "_test_data"


def _collect_available_tests(attrs):
    return {attr_name: attr for attr_name, attr in attrs.items() if _is_test(attr_name)}


def _collect_available_base_tests(bases):
    base_tests = dict()
    for base in bases:
        base_test_names = [name for name in dir(base) if _is_test(name)]
        for test_name in base_test_names:
            if test_name not in base_tests:
                base_tests[test_name] = getattr(base, test_name)

    return base_tests


def _collect_all_tests(attrs, bases):
    test_attrs = _collect_available_tests(attrs)
    base_attrs = _collect_available_base_tests(bases)

    # order matters
    return base_attrs | test_attrs


def _collect_testing_data_tests(testing_data):
    # TODO: some filtering may occur here
    # TODO: play with `__` for markers? really need this?
    return [attr_name for attr_name in dir(testing_data) if _is_test_data(attr_name)]


def _filter_test_funcs_given_data(test_attrs, data_names_ls):
    # TODO: need to think about skips; probably after
    relevant_test_attrs = dict()
    assigned_data_names = []
    for attr_name, attr in test_attrs.items():
        data_name = _test_name_to_test_data_name(attr_name)
        if data_name in data_names_ls:
            assigned_data_names.append(data_name)
            relevant_test_attrs[attr_name] = attr

    if len(assigned_data_names) != len(data_names_ls):
        missing_tests = set(data_names_ls).difference(assigned_data_names)
        msg = "Need to define tests for:"
        for data_name in missing_tests:
            msg += f"\n\t-{data_name}"

        raise Exception(msg)

    return relevant_test_attrs


class DataBasedParametrizer(type):
    def __new__(cls, name, bases, attrs):
        all_test_attrs = _collect_all_tests(attrs, bases)

        testing_data = locals()["attrs"].get("testing_data")
        if testing_data is None:
            raise Exception(
                "Testing class doesn't have class object" " named 'testing_data'"
            )

        data_names_ls = _collect_testing_data_tests(testing_data)
        selected_test_attrs = _filter_test_funcs_given_data(
            all_test_attrs, data_names_ls
        )

        for attr_name, attr_value in selected_test_attrs.items():
            test_func, default_values = _copy_func(attr_value)
            attrs[attr_name] = _parametrize_test_func(
                test_func, attr_name, testing_data, default_values
            )

        for attr_name, attr_value in all_test_attrs.items():
            if attr_name not in selected_test_attrs:
                test_func, _ = _copy_func(attr_value)

                attrs[attr_name] = pytest.mark.ignore()(test_func)

        return super().__new__(cls, name, bases, attrs)
