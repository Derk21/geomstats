import inspect
import types

import pytest

import geomstats.backend as gs


def copy_func(f, name=None):
    """Return a function with same code, globals, defaults, closure, and
    name (or provide a new name).

    Additionally, keyword arguments are transformed into positional arguments for
    compatibility with pytest.
    """
    fn = types.FunctionType(
        f.__code__, f.__globals__, name or f.__name__, f.__defaults__, f.__closure__
    )
    fn.__dict__.update(f.__dict__)

    sign = inspect.signature(fn)
    defaults, new_params = {}, []
    for param in sign.parameters.values():
        if param.default is inspect._empty:
            new_params.append(param)
        else:
            new_params.append(inspect.Parameter(param.name, kind=1))
            defaults[param.name] = param.default
    new_sign = sign.replace(parameters=new_params)
    fn.__signature__ = new_sign

    return fn, defaults


class TestBasedParametrizer(type):
    """Metaclass for test classes.

    Note: A test class is a class that inherits from TestCase.
    For example, `class TestEuclidean(TestCase)` defines
    a test class.

    The Parametrizer helps its test class by pairing:
    - the different test functions of the test class:
      - e.g. the test function `test_belongs`,
    - with different test data, generated by auxiliary test data functions
      - e.g. the test data function `belongs_data` that generates data
      to test the function `belongs`.

    As such, Parametrizer acts as a "metaclass" of its test class:
    `class TestEuclidean(TestCase, metaclass=Parametrizer)`.

    Specifically, Parametrizer decorates every test function inside
    its test class with pytest.mark.parametrizer, with the exception
    of the test class' class methods and static methods.

    Two conventions need to be respected:
    1. The test class should contain an attribute named 'testing_data'.
      - `testing_data` is an object inheriting from `TestData`.
    2. Every test function should have its corresponding test data function created
    inside the TestData object called `testing_data`.

    A sample test class looks like this:

    ```
    class TestEuclidean(TestCase, metaclass=Parametrizer):
        class TestDataEuclidean(TestData):
            def belongs_data():
                ...
                return self.generate_tests(...)
        testing_data = TestDataEuclidean()
        def test_belongs():
            ...
    ```
    Parameters
    ----------
    cls : child class of TestCase
        Test class, i.e. a class inheriting from TestCase
    name : str
        Name of the test class
    bases : TestCase
        Parent class of the test class: TestCase.
    attrs : dict
        Attributes of the test class, for example its methods,
        stored in a dictionnary as (key, value) when key gives the
        name of the attribute (for example the name of the method),
        and value gives the actual attribute (for example the method
        itself.)

    References
    ----------
    More on pytest's parametrizers can be found here:
    https://docs.pytest.org/en/6.2.x/parametrize.html
    """

    def __new__(cls, name, bases, attrs):
        """Decorate the test class' methods with pytest."""
        for base in bases:
            test_fn_list = [fn for fn in dir(base) if fn.startswith("test")]
            for test_fn in test_fn_list:
                if test_fn not in attrs:
                    attrs[test_fn] = getattr(base, test_fn)

        skip_all = attrs.get("skip_all", False)

        testing_data = locals()["attrs"].get("testing_data", None)
        if testing_data is None:
            raise Exception(
                "Testing class doesn't have class object" " named 'testing_data'"
            )
        cls_tols = (
            testing_data.tolerances if hasattr(testing_data, "tolerances") else {}
        )

        for attr_name, attr_value in attrs.copy().items():
            if not (
                attr_name.startswith("test")
                and isinstance(attr_value, types.FunctionType)
            ):
                continue

            test_func, default_values = copy_func(attr_value)

            if (
                not skip_all
                and ("skip_" + attr_name, True) not in locals()["attrs"].items()
            ):
                arg_names = inspect.getfullargspec(test_func)[0]
                args_str = ", ".join(arg_names[1:])

                test_data = _get_test_data(
                    attr_name,
                    testing_data,
                    arg_names,
                    cls_tols,
                    default_values,
                )

                attrs[attr_name] = pytest.mark.parametrize(
                    args_str,
                    test_data,
                )(test_func)
            else:
                attrs[attr_name] = pytest.mark.skip("skipped")(test_func)

        return super().__new__(cls, name, bases, attrs)


def _get_test_data(test_name, testing_data, test_arg_names, cls_tols, default_values):
    short_name = test_name[5:]
    suffixes = ["", "_smoke", "_random"]

    data_fn_ls = [f"{short_name}{suffix}_test_data" for suffix in suffixes]

    has_method = False
    for data_fn_str in data_fn_ls:
        if hasattr(testing_data, data_fn_str):
            has_method = True
            break

    # TODO: this verification should be done somewhere else
    if not has_method:
        raise Exception(
            f"testing_data object doesn't have '{short_name}_test_data' "
            f"function for pairing with '{test_name}'"
        )

    test_data = []
    for data_fn_str in data_fn_ls:
        if not hasattr(testing_data, data_fn_str):
            continue

        test_data_ = getattr(testing_data, data_fn_str)()
        if test_data_ is None:
            raise Exception(f"'{data_fn_str}' returned None. should be list")
        test_data.extend(test_data_)

    test_data = _dictify_test_data(test_data, test_arg_names[1:])
    test_data = _handle_tolerances(
        test_name[5:],
        test_arg_names[1:],
        test_data,
        cls_tols,
    )
    test_data = _pytestify_test_data(
        test_name, test_data, test_arg_names[1:], default_values
    )

    return test_data


def _dictify_test_data(test_data, arg_names):
    tests = []
    for test_datum in test_data:
        if not isinstance(test_datum, dict):
            test_datum = dict(zip(arg_names, test_datum[:-1]))
            test_datum["marks"] = test_datum[-1]

        tests.append(test_datum)

    return tests


def _handle_tolerances(func_name, arg_names, test_data, cls_tols):

    has_tol = False
    for arg_name in arg_names:
        if arg_name.endswith("tol"):
            has_tol = True
            break

    if not has_tol:
        return test_data

    func_tols = cls_tols.get(func_name, {})

    tols = {}
    for arg_name in arg_names:
        if arg_name.endswith("rtol"):
            tols[arg_name] = func_tols.get(arg_name, gs.rtol)
        elif arg_name.endswith("tol"):
            tols[arg_name] = func_tols.get(arg_name, gs.atol)

    for test_datum in test_data:
        for tol_arg_name, tol in tols.items():
            test_datum.setdefault(tol_arg_name, tol)

    return test_data


def _pytestify_test_data(func_name, test_data, arg_names, default_values):
    tests = []
    for test_datum in test_data:
        try:
            values = [
                test_datum.get(key) if key in test_datum else default_values[key]
                for key in arg_names
            ]

        except KeyError:
            raise Exception(
                f"{func_name} requires the following arguments: "
                f"{', '.join(arg_names)}"
            )
        tests.append(pytest.param(*values, marks=test_datum.get("marks")))

    return tests


def _is_test(attr_name):
    return attr_name.startswith("test_")


def _is_test_data(attr_name):
    return attr_name.endswith("_test_data")


def _test_name_to_test_data_name(test_name):
    return test_name[5:] + "_test_data"


def _collect_available_tests(attrs):
    return {attr_name: attr for attr_name, attr in attrs.items() if _is_test(attr_name)}


def _collect_available_base_tests(bases):
    base_tests = dict()
    for base in bases:
        base_test_names = [name for name in dir(base) if _is_test(name)]
        for test_name in base_test_names:
            if test_name not in base_tests:
                base_tests[test_name] = getattr(base, test_name)

    return base_tests


def _collect_testing_data_tests(testing_data):
    # TODO: some filtering may occur here
    # TODO: play with `__` for markers? really need this?
    return [attr_name for attr_name in dir(testing_data) if _is_test_data(attr_name)]


def _filter_test_funcs_given_data(test_attrs, data_names_ls):
    relevant_test_attrs = dict()
    for attr_name, attr in test_attrs.items():
        data_name = _test_name_to_test_data_name(attr_name)
        if data_name in data_names_ls:
            relevant_test_attrs[attr_name] = attr

    return relevant_test_attrs


class DataBasedParametrizer(type):
    def __new__(cls, name, bases, attrs):
        test_attrs = _collect_available_tests(attrs)
        base_attrs = _collect_available_base_tests(bases)

        # order matters
        all_test_attrs = base_attrs | test_attrs

        testing_data = locals()["attrs"].get("testing_data")
        if testing_data is None:
            raise Exception(
                "Testing class doesn't have class object" " named 'testing_data'"
            )

        data_names_ls = _collect_testing_data_tests(testing_data)
        selected_test_attrs = _filter_test_funcs_given_data(
            all_test_attrs, data_names_ls
        )

        for attr_name, attr_value in selected_test_attrs.items():
            test_func, default_values = copy_func(attr_value)

            arg_names = inspect.getfullargspec(test_func)[0]
            args_str = ", ".join(arg_names[1:])

            # TODO: allow marks from data in this case?
            # no args case (note selection was done above)
            if len(arg_names) == 1:
                attrs[attr_name] = test_func
                continue

            test_data = _get_test_data(
                attr_name,
                testing_data,
                arg_names,
                {},  # TODO: handle tols
                default_values,
            )

            attrs[attr_name] = pytest.mark.parametrize(
                args_str,
                test_data,
            )(test_func)

        for attr_name, attr_value in all_test_attrs.items():
            if attr_name not in selected_test_attrs:
                test_func, _ = copy_func(attr_value)

                attrs[attr_name] = pytest.mark.ignore()(test_func)

        return super().__new__(cls, name, bases, attrs)
